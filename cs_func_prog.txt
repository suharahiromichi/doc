1. 技術紹介：関数型言語と関数プログラミングについて
2. 発表要旨
1. 関数型言語（PCF、Programming language for Computable Function）、論理学的、数学的な概念「だけ」を基礎持つ。でも個々の概念は難しくない。
1. ラムダ計算、関数呼出と関数定義のこと。
2. 代数データ型、直和と直積 (Cのunionとstruct)
3. 帰納的関数定義（Cの普通の関数定義）
4. 条件分岐として、if-then-else または match (Cのcase)
1. 歴史的な背景、関数プログラミングの歴史はコンピュータの歴史より古い。
1. 1930年、数論を含む第一階述語論理は不完全性である（ゲーデル）
2. 1936年、ラムダ計算の停止性問題は決定不能（チャーチ）
3. 1936年、チューリングマシンの停止性問題は決定不能（チューリング）
4. 1943年、ラムダ計算もチューリングマシンも普遍的な「計算」（クリーネ）
5. 1945年、EDVACレポート（ノイマン）
6. 1973年、SASL、MLが発表（ターナー、ミルナー）
7. 1977年、PCFの提案（ミルナー）
8. 1985年ころ、人工知能ブーム
1. 関数型言語の目指すこと。「実用言語としての能力を失わずに、プログラマにバグのあるコードを書かせないようにする。言い換えると、コンパイル時に「正しさ」のチェックができるので、コンパイルできたプログラムは、「正しく」動く」。
2. どこまで実現できたか（バグのあるコードを書かせない）。
1. ラムダ計算に、型を導入することで停止性を保証する。止まらない関数は、型が表現できないので定義できない。
2. 帰納的関数に、代数データ型を導入することで停止性を保証する。同じ型の値の間に大小関係が決まるので、小さい方に繰り返していれば、そのうち止まる。
3. matchの条件分岐が、代数データ型の直積、直和の構造と一致すること。一致しなければ、matchのエラーにする。「構造化プログラミング」の完成形。
1. どこまで実現できたか（実用言語としての能力）
1. 型宣言にワイルドカードを使用できる。意識せず「ジェネリック・プログラミング」ができる。
2. 高階関数を無制限に使用できる。制御構造を自分で定義できる（デザインパターン的。あまりに無秩序にならないための枠組みとして、「モナド」がある）。
1. これらを支える技術
1. ガーベージコレクション（今回は説明しない）
2. 型チェック・型推論。極めて単純な機構で実現できる。
1. 今後の発展
1. 依存型データ型。型の中に条件式や数値を含めることで、仕様を満たさないデータ（状態）が存在できない（仕様を満たさないプログラムが書けない）ようにする。
2. 定理証明系（型チェック機構の応用）との統合。仕様に基づく「意味」を導入して「正しさ」の範囲を広げる。プログラムに証明を添付しないと、コンパイルが通らないようにする。
1. 主な採用実績（略）、主な処理系（略）                        
1. 伝えたい技術ポイント
1. オブジェクト指向言語の使用が一般的になってきているが、その限界も見えてきている（デバックが大変）。それと相補的な関係のある関数型言語について、文法的な解説ではなく、それによって何が解決できるのか、プログラミングがどのように変わるのかという視点から説明をおこなう。
2. ソフトウェア技術との関連で語られることの少ない「コンピュータ前史」の説明をして、形式手法などの技術や、プログラミング言語の設計が、100年に渡る理論計算機科学の成果に支えられていることを説明する。
3. 関数型言語をつかわなくても関数プログラミングの考えかたを活用するのは不可能ではないが、そのためには、関数型言語を取得しておくことが必須である。
