Simple simpl

Pierre Boutillier

-----

# Introduction

この記事では、代数データ構造、fixpoint、グローバル定数を含むラムダ計算の
拡張の削減の問題について説明します。 これは、Coq [9] などの証明アシス
タントのプログラミング言語のコアを表しています。 その文法を図1に示しま
す。

代数的データ型はコンストラクターによって導入されます。 保存される情報
は、「これはそのデータ型のi番目のコンストラクターです」です。 代数的デー
タ型は、デストラクタと呼ばれるものによって排除されます。 これは、ケー
ス分析のみ、またはフィックスポイント定義内のケース分析のいずれかです。
ケース分析のブランチは、コンストラクターの引数を直接バインドしません。
k個の引数を持つコンストラクターのブランチは、k個の関数抽象化で開始する
必要があります。

証明アシスタントでは、この言語は強く型付けされ、型注釈が付けられます。
私たちの目標に集中し続けるために、私たちはすべてがうまくタイプされてい
ると仮定します。

私たちの言語は、4つの非構造的ルールによって特徴付けられる小さなステッ
プのセマンティクスに恵まれています。

- β-reduction  functional elimination
- δ-reduction  constant unfolding
- ι-reduction  Algebraic datatypes elimination

  - i番目のコンストラクタでのパターンマッチングは、コンストラクタ
引数に適用されるi番目のブランチに置き換えられます。
  - コンストラクタに適用されたfixpointは、その本体に置き換えられます。

大きなステップのセマンティクスは、抽象マシンを構築し、評価手法による型
なしの正規化に従うことで取得できます[5、8]。 この手法は、デフォルトで、
長さが元の用語よりも大幅に大きい可能性がある正規形に応答します。 特に、
グローバル定数と自由変数が関係している場合、展開された形式は一見認識し
にくい場合があります。

簡潔に保ちながら縮小することは矛盾しているように見えるかもしれませんが、
簡単な例で、単純な正規化よりもどのような拡張を実現できるかを説明できま
す。 ゼロ（O）または整数n（S n）の後続として定義された単項整数と、次の
ように定義された定数を取ります。

```
Definition plus := fun m =>
     fix pl := fun n =>
          case n with
          | 0    => m
          | S n' => fun n' => S (pl n')
          end.
```

βδι-reductionに関する ``plus x (S (S y))`` の正規形は、
``S (S (plus x y))`` ではなく、
``S (S (fix pl := fun n => case n of | x | fun n' => S (pl n') end y))`` です。

生成的な方法でfixpointを定義することもできます。fixpointはグローバル定数を
定義するトップレベルのオブジェクトであり、再帰呼び出しはこの定数の呼び
出しです。 ただし、ここで検討する設計では、無名のfixpointを扱います。 名
前は、fixpoint式に対してローカルです。 スケルトンだけに意味があり、バイ
ンダーのモジュロ名前変更に相当する2つの定義が同等です。 2つのアプロー
チの違いについてはこれ以上説明しません。 さらなる考えは[10、1]にありま
す。 証明アシスタントのユーザーのレベルで停止しましょう。拡張されたロー
カル定義よりも定数を使用すると、目標が読みやすく、直感的になります。

Coq証明アシスタントは、``simpl`` と呼ばれる一般的な簡約戦略を備えてお
り、簡約を実行しますが、定数を展開するのは次の場合のみです。

1. 代数データ構造デストラクタが頭の位置にあることにつながります。

2. このデストラクタはι-reductionによって排除できます。

さらに、再帰呼び出しは、次の定数に置き換えられます。fixpoint定義の代わり
に展開されました。

これは多くのCoq証明の礎石ですが、*その複雑さは展開されない定数の数にお
いて指数関数的です*。 ``plus m (plus n p)`` の減少は、望ましくない動作
を示します。

1. 最初の``plus``を展開しようとします。

2. ι-reductionが ``plus n p`` の結果に依存することを確認します。

3. ``plus n p`` を再帰的に簡約しようとします。

4. コンストラクタに還元されないことを確認します。

5. 最初のプラスを展開しませんが、subtermで自分自身を呼び出します。

6. ``plus n p`` をもう一度減らします。

定数プラスは、n回出現した場合、2n回展開しようとします。

simplの実装は、定数のカスケード（δ-reductionのチェーンを介してfixpoint
に展開される定数）を処理するときの動作も予測できません。 実際、展開は、
カスケードが発生するコンテキストによって異なります。

この論文では、Bruno Barrasによって[2、第2章]で提案された代数的データ型
を持つKrivine Abstract Machineのバリアントに直接基づいた新しい実装を提
案しますが、一定の展開に関しては単純なように動作します。 重要なアイデ
アは、削減される用語に変換可能な定数のリストを維持することです。

## Outline

この論文は次のように構成されています。

セクション1では、call by name 簡約の戦略の実装を提案します。

セクション2では、展開された定数を追跡するために前のセクションをどのよ
うに改善するかについて説明します。

セクション3では、明示的な置き換えを使用することで、簡約のマシン効率と、
項のrefoldの能力の両方を改善する方法について説明します。

セクション4では、次の範囲を分析します。私たちの簡約戦略は、ユーザーに
よって微調整される可能性があります。

セクション5では、実装の選択肢のいくつかについて説明します。

(略)

