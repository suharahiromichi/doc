Simple simpl

Pierre Boutillier

-----

# Introduction

この記事では、代数データ構造、fixpoint、グローバル定数を含むラムダ計算の
拡張の削減の問題について説明します。 これは、Coq [9] などの証明アシス
タントのプログラミング言語のコアを表しています。 その文法を図1に示しま
す。

```
t, u :=
     x
   | t u
   | fun x => t
   | c                                         (* 定数 *)
   | C_i                                       (* コンストラクタ *)
   | case t of u_1 | … | u_i | … | u_p end   (* t が C_i … なら u_i *)
   | fix f := t
```

代数的データ型はコンストラクタによって導入されます。 保存される情報は、
「これはそのデータ型のi番目のコンストラクタです」です。 代数的データ型
は、デストラクタと呼ばれるものによって除去(eliminate)されます。 これは、
ケース分析のみ、またはfixpoint定義内のケース分析のいずれかです。case分
析のブランチは、コンストラクタの引数を直接バインドしません。k個の引数
を持つコンストラクタのブランチは、k個の関数抽象化で開始する必要があり
ます。

証明アシスタントでは、この言語は強く型付けされ、型注釈が付けられます。
私たちの目標に集中し続けるために、私たちはすべてがうまくタイプされてい
ると仮定します。

私たちの言語は、4つの非構造的ルールによって特徴付けられる小さなステッ
プのセマンティクスに恵まれています。

- β-reduction  (functional elimination) 関数の除去


``γ├ (fun x => t) u → t[u/x]``


- δ-reduction  (constant unfolding) 定数の展開

``γ; c := t; γ'├ c → t``

- ι-reduction  (Algebraic datatypes elimination) 代数データ型の除去

  - i番目のコンストラクタでのパターンマッチングは、コンストラクタ
引数に適用されるi番目のブランチに置き換えられます。

``γ ├ case C_i t_1 … t_n of | u_1 | … | u_p end → u_i t_1 … t_n``
 
  - コンストラクタに適用されたfixpointは、その本体に置き換えられます。

``γ ├ (fix f := t) (Ci u1 … u) → t[(fix f := t) / f] (Ci u1 … u)``

Big-Stepのセマンティクスは、抽象マシンを構築し、評価手法による型なしの
正規化に従うことで取得できます[5、8]。 この手法は、デフォルトで、長さ
が元の項よりも大幅に大きい可能性がある正規形を返します。 特に、グロー
バル定数と自由変数が関係している場合、展開(unfold)された形式は一見認識
しにくい場合があります。

単純さを保ちながら簡約することは矛盾しているように見えるかもしれません
が、簡単な例で、単純な正規化よりもどのような拡張を実現できるかを説明で
きます。 ゼロ 0 または、整数 n の後者 ``(S n)`` として定義された単項整
数と、次のように定義された定数を取ります。
 
```
plus := fun m =>
     fix pl := fun n =>
          case n of
          | m                         (* C_0 の場合 O の意味。 *)
          | fun n' => S (pl n')       (* C_1 の場合 S の意味。 *)
          end
```

βδι-reductionに関する ``plus x (S (S y))`` の正規形は、
``S (S (plus x y))`` ではなく、

```
S (S (fix pl := fun n => case n of
                         | x
                         | fun n' => S (pl n')
                         end
      y))
```

です。

生成的な方法でfixpointを定義することもできます。fixpointはグローバル定数を
定義するトップレベルのオブジェクトであり、再帰呼び出しはこの定数の呼び
出しです。 ただし、ここで検討する設計では、無名のfixpointを扱います。 名
前は、fixpoint式に対してローカルです。 スケルトンだけに意味があり、バイ
ンダーのモジュロ名前変更に相当する2つの定義が同等です。 2つのアプロー
チの違いについてはこれ以上説明しません。 さらなる考えは[10、1]にありま
す。 証明アシスタントのユーザーのレベルで停止しましょう。拡張されたロー
カル定義よりも定数を使用すると、目標が読みやすく、直感的になります。

Coq証明アシスタントは、``simpl`` と呼ばれる一般的な簡約戦略を備えてお
り、簡約を実行しますが、定数を展開するのは次の場合のみです。

1. 代数データ構造デストラクタが頭の位置にあることにつながります。

2. このデストラクタはι-reductionによって除去(eliminate)できます。

さらに、再帰呼び出しは、次の定数に置き換えられます。fixpoint定義の代わり
に展開されました。

これは多くのCoq証明の礎石ですが、*その複雑さは展開されない定数の数につ
いて指数関数的です*。 ``plus m (plus n p)`` の簡約は、望ましくない動作
を示します。

1. 最初の``plus``を展開しようとします。

2. ι-reductionが ``plus n p`` の結果に依存することを確認します。

3. ``plus n p`` を再帰的に簡約しようとします。

4. コンストラクタに還元されないことを確認します。

5. 最初のプラスを展開しませんが、subtermで自分自身を呼び出します。

6. ``plus n p`` をもう一度減らします。

定数プラスは、n回出現した場合、2n回展開しようとします。

simplの実装は、定数のカスケード（δ-reductionのチェーンを介してfixpoint
に展開される定数）を処理するときの動作も予測できません。 実際、展開は、
カスケードが発生するコンテキストによって異なります。

この論文では、Bruno Barrasによって[2、第2章]で提案された代数的データ型
を持つKrivine Abstract Machineの派生形に直接基づいた新しい実装を提案し
ますが、一定の展開に関しては単純なように動作します。 重要なアイデアは、
削減される項に変換可能な定数のリストを維持することです。

## Outline

この論文は次のように構成されています。

セクション1では、call by name 簡約の戦略の実装を提案します。

セクション2では、展開された定数を追跡するために前のセクションをどのよ
うに改善するかについて説明します。

セクション3では、明示的な置き換えを使用することで、簡約のマシン効率と、
項のrefoldの能力の両方を改善する方法について説明します。

セクション4では、次の範囲を分析します。私たちの簡約戦略は、ユーザーに
よって微調整される可能性があります。

セクション5では、実装の選択肢のいくつかについて説明します。

(略)

