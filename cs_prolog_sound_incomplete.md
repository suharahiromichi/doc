Prologは定理証明系として健全だが完全ではない
==============
2013/08/15      @suharahiromichi

2014/04/19      @suharahiromichi、追記

# Prologの健全性と完全性
## 健全性と完全性
第一階述語論理（Horn節に限定）の定理証明系として、Prologは健全だが、完全ではない。

* 健全性：××が健全とは、全ての、××で証明できる論理式は、充足可能な論理式である。
* 完全性：××が完全とは、全ての、充足可能な論理式は、××で証明できる論理式である。

 + 「全ての」は論理式にかかる。
 + 「充足可能」とは、変数に具体的な値を当てはめて、と言い換えてよい。ただし述語論理なので。
 + 「証明できる」とは、**有限**の証明がある、と言い換えてよい。
 + 健全性と完全性は、「逆」の関係にある。


## 導出原理(Resolution)
Resolutionは、健全かつ完全である。

コワルスキの「論理による問題の解決」([文献1.])には、
>証明手続の完全性を保証するためには、
>探索空間が完全であるばかりでなく、
>探索戦略もすべての場合を尽くさなければならない。

と書いてある。この本はPrologについて述べてはい**ない**ことに注意。
もう少し厳密にいうと、
ResolutionにおけるSLD反駁そのものは計算規則について独立、つまり、
導出のステップにおいて次にゴールのどの述語を展開するかを規定しないからである。
つまり、コワルスキは計算規則が適切なら完全だ、と言っているわけだ。


## 出現チェック(Occurs Check)
ResolutionにおいてOccurs Checkを省くと**健全性**が失われる。

「論理プログラミングの基礎」にある例 ([文献2.]p.49、表記は改めた)：

    test :- p(X, X).
    p(X, f(X)).

    ?- test.

Occurs Checkをしない場合、p(X, X)とp(Y, f(Y))が一致されてしまい、結果はyesとなる。
これは、健全性に対する反例になっている。

Occurs Checkを省いても証明できる論理式が減ることはないので、完全性が失われることはない。


## Prolog
Prologは、深さ優先探索をするので、**完全性**が保証されない。

Prologは、Resolutionにおける節の選択を、最左から深さ優先で探索することで実行するものである。
SLD反駁の計算規則を厳密に定めたものがPrologであるといえる。

健全性はResolutionの場合と同様に成立する。ひとたび証明できてしまえば同じであるため。

### 例1
具体的にいうと、ゴールの最左の論理式が無限に展開できてしまう場合は証明が終わらず、
その論理式は証明できないことになる。これは完全性に対する反例になっている。

「論理プログラミングの基礎」にある例 ([文献2.]p.59、表記は改めた)：

    p(X, Z) :- q(X, Y), p(Y, Z).
    p(X, X).
    q(a, b).

    ?- p(X, b).

これは、X=aの解があるが、第一節を
   p(X, Z) :- p(Y, Z), q(X, Y). 
とするか、または、最**右**から深さ優先で探索すると、探索木の展開が無限になり、証明できない。

### 例2
Prologのようなシーケンシャルな探索をおこなう限り、
証明できないプログラムが存在する。

「論理プログラミングの基礎」にある例 ([文献2.]p.62、表記は改めた)：

    p(a, b).                            % 1.
    p(c, b).                            % 2.
    p(X, Z) :- p(X, Y), p(Y, Z).        % 3.
    p(X, Y) :- p(Y, X).                 % 4.

    ?- p(a, c).                         % goal

これは、
                p(a, c)
        p(a, Y)         p(Y, c)
        p(a, b)         p(c, Y)
        成功            p(c, b)
                        成功

と探索木が展開でき成功する。
これは人間が介入して恣意的に解いた場合で、
[文献2.]では「探索規則がフェアである」という（可能性を見過ごさないということ）。
しかし、シーケンシャルな探索はフェアではないので、
3.を繰り返すか、4.を繰り替えしてしまい、終了しない。


## 失敗による否定
失敗を否定とみなす規則：

論理式Aの否定(~A)が証明できることを、Aがシーケンシャルな検索で失敗する（有限失敗）と定める。

有限失敗と否定の関係について、エルブラン・ベースを使った説明は以下を参照のこと。
https://github.com/suharahiromichi/doc/blob/master/cs_prolog_denotational_semantics.md


# 課題
## 上記の事項を形式的に証明したい。

* Resolutionの完全性を証明したい。健全性は証明されている[文献4.]。
* そのほか。

## Prologの個々のプログラムについて、完全性を証明する。
具体的には、型付きラムダ式の型推論を行うプログラム

    https://github.com/suharahiromichi/prolog/blob/master/tapl/tapl_type_stlc.swi

は、論理式をPrologで証明しているとみてよいので、結果として完全性が保証され**ない**のだろう。

ならば、どうすれば完全性が保証できるのだろうか。停止性を保証すればよいのだろうか。

型推論の健全性と完全性

* 健全性：あるプログラムの型推論で得られる、全ての型の組み合わせは、そのプログラムに正しく型を与える。
* 完全性：あるプログラムに正しく型を与える、全ての型の組み合わせは、そのプログラムの型推論で得られる。

 + 「全ての」は「型の組み合わせ」に掛かる。
 + 健全性と完全性は、「逆」の関係にある。
 + 正しく型が与えられたプログラムはエラーなく実行できる（型システムの安全性）。
 + 型システムの安全性は「進行性」と「型の保存性」からなる。
型システムの安全性を型システムの健全性という場合もある。これは型推論の健全性とは異なるので注意。


# 参考文献

1. R.コワルスキ、浦 監訳「論理による問題の解決」培風館
2. J.W.ロイド、佐藤 他訳「論理プログラミングの基礎」産業図書
3. Benjamin C. Pierce、住井 監訳「型システム入門  プログラミング言語と型の理論」
4. ジャック・ガリグ、 2013年度前期・数理解析・計算機数学 II (同 概論II)、名古屋大学大学院多元数理科学研究科
http://www.math.nagoya-u.ac.jp/~garrigue/lecture/2013_SS/index.html
5. 五十嵐 淳「ＭＬ型推論の光と影」、京都大学
http://www.sato.kuis.kyoto-u.ac.jp/~igarashi/class/isle4-11w/OCaml-meeting0908-revised.pdf

**以上**
